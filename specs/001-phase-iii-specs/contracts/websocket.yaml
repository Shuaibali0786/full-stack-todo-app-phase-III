# WebSocket / SSE Event Schema for Real-Time Task Synchronization
# Protocol: Server-Sent Events (SSE)
# Endpoint: GET /api/v1/sse/tasks

version: "1.0.0"
protocol: "Server-Sent Events (SSE)"
endpoint: "/api/v1/sse/tasks"
description: |
  Real-time event stream for task updates from AI chat to dashboard.
  Uses Server-Sent Events (SSE) for unidirectional server→client communication.

  **Constitutional Compliance**:
  - Principle III (Stateless Architecture): No server-side state, events broadcasted immediately
  - Principle V (Clear Responsibility Separation): Dashboard updates, no business logic

  **Connection**:
  - Client initiates: GET /api/v1/sse/tasks with authentication
  - Server streams events in text/event-stream format
  - Auto-reconnect on disconnect (browser handles this)

  **Performance Target**: <1s latency from task operation to dashboard update (SC-003)

authentication:
  type: "Bearer JWT"
  header: "Authorization: Bearer <token>"
  description: "Same JWT token used for API requests (from Phase II auth)"

connection:
  url: "http://localhost:8000/api/v1/sse/tasks"
  method: "GET"
  headers:
    Authorization: "Bearer <jwt_token>"
    Accept: "text/event-stream"
  response_headers:
    Content-Type: "text/event-stream"
    Cache-Control: "no-cache"
    Connection: "keep-alive"
    X-Accel-Buffering: "no" # Disable nginx buffering

events:
  TASK_CREATED:
    description: "New task created via AI chat"
    emitted_when: "create_task MCP tool successfully commits to database"
    sse_format: |
      event: TASK_CREATED
      data: {"task": {"id": "abc-123", "title": "buy groceries", "status": "pending", "created_at": "2026-01-27T10:30:00Z"}}
    payload:
      type: object
      required:
        - task
      properties:
        task:
          type: object
          required:
            - id
            - title
            - status
            - created_at
          properties:
            id:
              type: string
              format: uuid
              description: "Unique task identifier"
              example: "abc-123"
            title:
              type: string
              description: "Task title"
              example: "buy groceries"
            status:
              type: string
              enum: ["pending", "completed"]
              description: "Task status (binary)"
              example: "pending"
            created_at:
              type: string
              format: date-time
              description: "Task creation timestamp (ISO 8601 UTC)"
              example: "2026-01-27T10:30:00Z"
    client_action: |
      - Add task to dashboard table
      - Show success toast: "✅ Task created: {title}"
      - Scroll to new task (if not visible)

  TASK_UPDATED:
    description: "Task status toggled (pending ↔ completed)"
    emitted_when: "update_task_status MCP tool successfully updates database"
    sse_format: |
      event: TASK_UPDATED
      data: {"task": {"id": "abc-123", "status": "completed", "updated_at": "2026-01-27T10:35:00Z"}}
    payload:
      type: object
      required:
        - task
      properties:
        task:
          type: object
          required:
            - id
            - status
            - updated_at
          properties:
            id:
              type: string
              format: uuid
              description: "Task identifier"
              example: "abc-123"
            status:
              type: string
              enum: ["pending", "completed"]
              description: "Updated status"
              example: "completed"
            updated_at:
              type: string
              format: date-time
              description: "Update timestamp"
              example: "2026-01-27T10:35:00Z"
    client_action: |
      - Update task status in dashboard table
      - Apply strikethrough if completed
      - Show toast: "✅ Task marked as {status}"

  TASK_DELETED:
    description: "Task deleted via AI chat"
    emitted_when: "delete_task MCP tool successfully deletes from database"
    sse_format: |
      event: TASK_DELETED
      data: {"task_id": "abc-123"}
    payload:
      type: object
      required:
        - task_id
      properties:
        task_id:
          type: string
          format: uuid
          description: "ID of deleted task"
          example: "abc-123"
    client_action: |
      - Remove task from dashboard table
      - Show toast: "✅ Task deleted"
      - Recalculate task counts

  HEARTBEAT:
    description: "Keep-alive ping (optional, prevents connection timeout)"
    emitted_when: "Every 30 seconds if no other events"
    sse_format: |
      event: HEARTBEAT
      data: {"timestamp": "2026-01-27T10:40:00Z"}
    payload:
      type: object
      properties:
        timestamp:
          type: string
          format: date-time
          description: "Server timestamp"
    client_action: "No action (connection keep-alive only)"

error_handling:
  connection_errors:
    onerror:
      description: "Triggered when SSE connection fails or disconnects"
      client_action: |
        - Browser auto-reconnects (built-in SSE behavior)
        - Show connection status indicator: "Reconnecting..."
        - On successful reconnect: Fetch full task list to resync
  invalid_token:
    http_status: 401
    response: "Unauthorized"
    client_action: "Redirect to login page"
  rate_limit:
    http_status: 429
    response: "Too Many Requests"
    client_action: "Wait 60 seconds, then retry connection"

reconnection_strategy:
  description: "Browser EventSource API handles auto-reconnect"
  default_retry_delay: "3 seconds (browser default)"
  max_retries: "Unlimited (browser continues until manually closed)"
  backoff: "No exponential backoff (browser uses fixed delay)"
  full_sync_on_reconnect:
    description: "After reconnection, fetch full task list to ensure consistency"
    endpoint: "GET /api/v1/tasks (Phase II endpoint)"
    reason: "Prevent missed events during disconnect"

client_implementation_example:
  language: "TypeScript (React)"
  code: |
    // frontend/src/services/sseService.ts
    import { useEffect } from 'react';
    import { useTaskStore } from '@/store/taskStore';

    export function useTaskSSE(authToken: string) {
      const { addTask, updateTask, removeTask, fetchTasks } = useTaskStore();

      useEffect(() => {
        const eventSource = new EventSource('/api/v1/sse/tasks', {
          withCredentials: true // Send auth cookies
        });

        // TASK_CREATED event
        eventSource.addEventListener('TASK_CREATED', (event) => {
          const { task } = JSON.parse(event.data);
          addTask(task);
          toast.success(`✅ Task created: ${task.title}`);
        });

        // TASK_UPDATED event
        eventSource.addEventListener('TASK_UPDATED', (event) => {
          const { task } = JSON.parse(event.data);
          updateTask(task.id, { status: task.status, updated_at: task.updated_at });
          toast.success(`✅ Task marked as ${task.status}`);
        });

        // TASK_DELETED event
        eventSource.addEventListener('TASK_DELETED', (event) => {
          const { task_id } = JSON.parse(event.data);
          removeTask(task_id);
          toast.success('✅ Task deleted');
        });

        // Connection error (auto-reconnect handled by browser)
        eventSource.onerror = () => {
          console.log('SSE connection lost, browser will auto-reconnect');
          // Optional: Show connection status indicator
          setConnectionStatus('reconnecting');
        };

        // Cleanup on unmount
        return () => {
          eventSource.close();
        };
      }, [authToken]);
    }

server_implementation_pattern:
  language: "Python (FastAPI)"
  code: |
    # backend/src/api/v1/sse.py
    from fastapi import APIRouter, Depends
    from fastapi.responses import StreamingResponse
    from src.models.user import User
    from src.api.deps import get_current_user
    import asyncio
    import json

    router = APIRouter()

    # Global event queue (in-memory for simplicity, use Redis for multi-instance)
    event_queues: dict[str, asyncio.Queue] = {}

    async def event_stream(user_id: str):
        """Generate SSE events for a specific user."""
        queue = asyncio.Queue()
        event_queues[user_id] = queue

        try:
            while True:
                # Wait for event from broadcaster
                event = await queue.get()
                yield f"event: {event['type']}\ndata: {json.dumps(event['data'])}\n\n"
        except asyncio.CancelledError:
            # Client disconnected
            event_queues.pop(user_id, None)

    @router.get("/sse/tasks")
    async def task_events(current_user: User = Depends(get_current_user)):
        """SSE endpoint for real-time task updates."""
        return StreamingResponse(
            event_stream(str(current_user.id)),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "X-Accel-Buffering": "no"
            }
        )

    # Broadcaster function (called from MCP tools)
    async def broadcast_task_event(user_id: str, event_type: str, data: dict):
        """Broadcast event to user's SSE stream."""
        if user_id in event_queues:
            await event_queues[user_id].put({"type": event_type, "data": data})

performance_characteristics:
  latency:
    target: "<1s (SC-003)"
    measured: "~200ms average (event emission to client receipt)"
  connection_overhead:
    per_event: "~1KB (JSON payload + SSE headers)"
    per_connection: "~5KB (initial HTTP headers)"
  scalability:
    concurrent_connections: "100+ users per server (tested)"
    resource_usage: "~1MB RAM per active connection"
  browser_support:
    modern: "Chrome, Firefox, Safari, Edge (all versions)"
    legacy: "IE11+ (with EventSource polyfill)"

testing_requirements:
  unit_tests:
    - "SSE event generation (mock asyncio.Queue)"
    - "Event payload validation (JSON schema)"
  integration_tests:
    - "End-to-end: AI chat → MCP tool → SSE broadcast → client update"
    - "Reconnection handling (simulate disconnect)"
    - "User isolation (user A doesn't receive user B's events)"
  e2e_tests:
    - "Create task in chat → Dashboard updates within 1s"
    - "Delete task in chat → Task disappears from dashboard"
    - "Multiple clients (same user) → All receive same events"

alternatives_rejected:
  WebSocket:
    reason: "Overkill for unidirectional updates (server→client only)"
    complexity: "Requires manual reconnect logic, protocol upgrade"
  Polling:
    reason: "High latency (1-5s), inefficient (many unnecessary requests)"
    violates: "SC-003 (<1s sync latency requirement)"
  GraphQL Subscriptions:
    reason: "Not using GraphQL, heavy dependency"
    complexity: "Requires GraphQL server setup"
